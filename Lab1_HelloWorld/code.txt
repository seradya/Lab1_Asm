#include "stm32l1xx.s"
 
  .syntax unified
  .cpu cortex-m3
  .fpu softvfp
  .thumb
 
.equ PERIOD, 10500
.equ ON_TIME, 520
 
SystemInit:
 
    bx lr  // Return
 
RCC_Init:
 
    mov r1, #1
    ldr r0, =(PERIPH_BB_BASE + (RCC_AHBENR - PERIPH_BASE) * 32 + 1*4) //Включение тактирования порта В
    str r1, [r0]
 
    ldr r0, =(PERIPH_BB_BASE + (RCC_AHBENR - PERIPH_BASE) * 32 + 0*4) //Включение тактирования порта В
    str r1, [r0]
 
    ldr r0, =(PERIPH_BB_BASE + (RCC_AHBENR - PERIPH_BASE) * 32 + 2*4) //Включение тактирования порта C
    str r1, [r0]
 
    bx lr
 
Gpio_Init:
 
    mov r1, #1
    ldr r0, =(PERIPH_BB_BASE + (GPIOC_MODER - PERIPH_BASE) * 32 + 26*4) //Включение режима push-pull для вывода PC13
    str r1, [r0]
 
    ldr r0, =(PERIPH_BB_BASE + (GPIOB_MODER - PERIPH_BASE) * 32 + 14*4) //Включение режима push-pull для вывода PB7
    str r1, [r0]
 
    bx lr
 
 
delay:								    // Подпрограмма задержки
	push	{r0}						// Загружаем в стек R0, т.к. его значение будем менять
	mov		r0, r7				        // псевдоинструкция Thumb (загрузить константу в регистр)
 
delay_loop:
	subs	r0, #1						// SUB с установкой флагов результата
	it 		NE
	bne		delay_loop					// переход, если Z==0 (результат вычитания не равен нулю)
	pop		{r0}						// Выгружаем из стека R0
	bx		lr							// выход из подпрограммы (переход к адресу в регистре LR - вершина стека)
 
 
Btn_read:
 
    ldr r0, =(PERIPH_BB_BASE + (GPIOA_IDR - PERIPH_BASE) * 32)              //Чтение кнопки PA0
    ldr r1, [r0]
 
    bx lr
 
 
main:
 
    bl RCC_Init                                                             //Настройка тактирования
    bl Gpio_Init                                                            //Инициализация периферии
 
    ldr r3, =(PERIPH_BB_BASE + (GPIOC_ODR - PERIPH_BASE) * 32 + 13*4)       //Запись адреса BB в регистр r3
    ldr r10, =(PERIPH_BB_BASE + (GPIOB_ODR - PERIPH_BASE) * 32 + 7*4)       //Запись адреса BB в регистр r10
 
    mov r1, #0                                                              //Регистр r1 инициализируется 0
    mov r5, #0                                                              //Регистр r5 хранит предыдущее состояние кнопки
    mov r4, #0                                                              //Регистр r4 хранит положение сервопривода (0: -90, 1: 90)
    mov r7, #0                                                              //Регистр r7 хранит вермя задержки
    ldr r9, =PERIOD                                                         //Регистр r9 хранит время периода
    mov r11, #0                                                             //Регистр r11 хранит 0
    mov r12, #1                                                             //Регистр r12 хранит 1
 
loop:
 
/////////////////////////////////////Управление сервоприводом/////////////////////////////////////
 
    bl Btn_read                         //В регистр r1 записывается состояние кнопки
 
    str r12, [r3]                       //На сервопривод подается высокий управляющий сигнал
 
    cmp r4, #1                          //Если сервопривод должен быть в положении 1
    ITTEE EQ                            //Тогда
    ldreq r7, =ON_TIME                  //Время задержки равно 1мс
    streq r11, [r10]                    //Включение светодиода (индикация состония)
                                        //Иначе
    ldrne r7, =ON_TIME*2                //Время задержки 2мс
    strne r12, [r10]                    //Выключение светодиода
 
    bl  delay                           //Выполнить задержку (1 или 2 мс)
 
    str r11, [r3]                       //На севропривод подается низкий управляющий сигнал
    sub r7, r9, r7                      //Рассчет времени задержки (20мс - 1 или 2 мс)
    bl  delay                           //Выполнить задержку (18 или 19 мс)
 
/////////////////////////////////////////////////////////////////////////////////////////////////
 
////////////////////////////////////Считывание нажатия кнопки////////////////////////////////////    
 
    cmp r1, #1                          
    ITT NE                              //Если кнопка не нажата
    movne r5, #0                        //Предыдущее состояния кнопки = 0
    bne loop                            //Вернуться в начало цикла
    cmp r1, r5                          //Иначе
    IT EQ                               //Если предыдущее состояние равно текущему
    beq loop                            //Вернуться в начало цикла
                                        //Если r1 = 1 и r5 = 0
    mov r5, #1                          //Предыдущее состояние равно 1
    eor r4, r4, #0x1                    //Инверсия последнего бита         
    b loop                              //Вернуться в начало цикла
 
/////////////////////////////////////////////////////////////////////////////////////////////////
